\section{Simon}
\begin{frame}{Simon}
	\begin{itemize}
	  \item Programming language
	  \item Hardware/software architecture
	  \item Physics implementation
	  \item Tasks/threads
	\end{itemize}
\end{frame}

\subsection{Programming Language}
\begin{frame}{Programming Language}
	\begin{itemize}
	  \item Choosing a programming language
	  \begin{itemize}
	  	\item NXC
	  \end{itemize}
	  \item Alternatives
	  \begin{itemize}
	    \item leJos
	  \end{itemize}
	\end{itemize}
\end{frame}

\subsection{Hardware/Software Architecture}
\begin{frame}{Hardware/Software Architecture}
\begin{onlyenv}
\only<1>{
	\begin{figure}[H]
  		\includegraphics[scale=0.45]{figures/HARCH.png}
	\end{figure}
	}
\only<2>{
	\begin{figure}[H]
		\includegraphics[scale=0.26]{figures/SequenceDiagram.png}
	\end{figure}
}
\only<3>{
	\begin{figure}[H]
		\includegraphics[scale=0.2]{figures/CallStack.png}
	\end{figure}
}
\end{onlyenv}
\end{frame}

\subsection{Physics Implementation}
\begin{frame}[fragile]{Physics Implementation}
\begin{minipage}[H]{0.9\linewidth}
 \begin{lstlisting}
PosData CalcFuturePos(DirectionVector vector, unsigned long time){
   PosData futurePosition;
   float tanInput = 0;
   futurePosition.xPos = vector.xPos + vector.speedX * time;
   futurePosition.yPos = vector.yPos + vector.speedY * time;
   futurePosition.time = CurrentTick() + time;

   tanInput = futurePosition.yPos / futurePosition.xPos;
   if(futurePosition.xPos >= 0)
        futurePosition.angle = 90+(atand(tanInput))*(-1);
   else
        futurePosition.angle = (90-(atand(tanInput))*(-1))*(-1);
   
   return futurePosition;
}
 \end{lstlisting} 
\end{minipage}
\end{frame}